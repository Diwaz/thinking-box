import { ChatGoogleGenerativeAI } from "@langchain/google-genai";
import { tool } from "@langchain/core/tools";
import * as z from "zod";
import { StateGraph, START, END, Command } from "@langchain/langgraph";
import { MessagesZodMeta } from "@langchain/langgraph";
import { registry } from "@langchain/langgraph/zod";
import { type BaseMessage } from "@langchain/core/messages";
import { isAIMessage, ToolMessage } from "@langchain/core/messages";
import { SystemMessage } from "@langchain/core/messages";
import { HumanMessage } from "@langchain/core/messages";
import { $ } from "bun";
import {exec} from "child_process"
import { applyPatch, createPatch } from "diff";


const llm = new ChatGoogleGenerativeAI({
  model: "gemini-2.5-flash",
});


const createfile = tool(
  async ({ filePath, content }) => {
    const file = Bun.file(filePath);
    await Bun.write(file, content);
    return `File created successfully at ${filePath}`
  }, {
  name: "creates_new_file",
  description: "Creates new file and adds content to it",
  schema: z.object({
    filePath: z.string().describe("File path of the origin of the file"),
    content: z.string().describe("content or code to put inside file")
  })
})

const runShellCommands = tool (
  async ({ command }) => {
    console.log("commdn",command);
    exec(`${command}`, (error, stdout, stderr) => {
    if (error) {
        console.log(`error: ${error.message}`);
        return;
    }
    if (stderr) {
        console.log(`stderr: ${stderr}`);
        return;
    }
    console.log(`stdout: ${stdout}`);
});

    return ` command executed in the terminal successfully `;
  },{
    name : "run_shell_command",
    description:"runs the shell command given by AI in the terminal",
    schema: z.object ({
      command: z.string().describe("shell command to run in bash terminal")
    })
  }
)
const applyPatchTool = tool (
  async ({file_to_edit,new_file})=>{
    console.log("applying patch")
    // apply patch logic 
    console.log("file path of the old file",file_to_edit)
    const oldFile = Bun.file(file_to_edit)
    const oldFilesContents = await oldFile.text();
    const patch = createPatch(file_to_edit,oldFilesContents,new_file)
    const patchedFile = applyPatch(oldFilesContents,patch)
    console.log("after applying patch",patchedFile)
    await Bun.write(file_to_edit,patchedFile)
  },
{
  name: "apply_patch_tool",
  description: "takes the file path of the old file to edit and new content to apply patch and updates the old file with updated content",
  schema: z.object({
    file_to_edit: z.string().describe("file path of the old file to edit new update generated by AI"),
    new_file: z.string().describe("new updated latest file given by the AI"),
  })
}
)

// const applyEditByLineReplace = tool (
//   async ({file_path, first_line,last_line, replace})=>{
//     console.log("applying patch")
//     // apply patch logic 
//   },
// {
//   name: "apply_edit_by_replacing_lines",
//   description: "Line-Based Search and Replace Tool\n\nUse this tool to find and replace specific content in a file you have access to, using explicit line numbers. This is the PREFERRED and PRIMARY tool for editing existing files. Always use this tool when modifying existing code rather than rewriting entire files.\n\nProvide the following details to make an edit:\n\t1.\tfile_path - The path of the file to modify\n\t2.\tsearch - The content to search for (use ellipsis ... for large sections instead of writing them out in full)\n\t3.\tfirst_replaced_line - The line number of the first line in the search (1-indexed)\n\t4.\tlast_replaced_line - The line number of the last line in the search (1-indexed)\n\t5.\treplace - The new content to replace the found content\n\nThe tool will validate that search matches the content at the specified line range and then replace it with replace.\n\nIMPORTANT: When invoking this tool multiple times in parallel (multiple edits to the same file), always use the original line numbers from the file as you initially viewed it. Do not adjust line numbers based on previous edits.\n\nELLIPSIS USAGE:\nWhen replacing sections of code longer than ~6 lines, you should use ellipsis (...) in your search to reduce the number of lines you need to specify (writing fewer lines is  the last few lines (typically 2-3 lines) of the section you want to replace\n- the key is to provide enough unique context at the beginning and end to ensure accurafaster).\n- Include the first few lines (typically 2-3 lines) of the section you want to replace\n- Add \"...\" on its own line to indicate omitted content\n- Includete matching\n- Focus on uniqueness rather than exact line counts - sometimes 2 lines is enough, sometimes you need 4\n\n\n\nExample:\nTo replace a user card component at lines 22-42:\n\nOriginal content in file (lines 20-45):\n20:   return (\n21:     \n22:       \n23:         \n24:         {user.name}\n25:         {user.email}\n26:         {user.role}\n27:         {user.department}\n28:         {user.location}\n29:         \n30:            onEdit(user.id)}>Edit\n31:            onDelete(user.id)}>Delete\n32:            onView(user.id)}>View\n33:         \n34:         \n35:           Created: {user.createdAt}\n36:           Updated: {user.updatedAt}\n37:           Status: {user.status}\n38:         \n39:         \n40:           Permissions: {user.permissions.join(', ')}\n41:         \n42:       \n43:     \n44:   );\n45: }\n\nFor a large replacement like this, you must use ellipsis:\n- search: \"      \\n        \\n...\\n          Permissions: {user.permissions.join(', ')}\\n        \\n      \"\n- first_replaced_line: 22\n- last_replaced_line: 42\n- replace: \"      \\n        \\n           {\\n              e.currentTarget.src = '/default-avatar.png';\\n            }}\\n          />\\n        \\n        \\n          {user.name}\\n          {user.email}\\n          \\n            {user.role}\\n            {user.department}\\n          \\n        \\n        \\n           onEdit(user.id)}\\n            aria-label=\\\"Edit user profile\\\"\\n          >\\n            Edit Profile\\n          \\n        \\n      \"\n\nCritical guidelines:\n\t1. Line Numbers - Specify exact first_replaced_line and last_replaced_line (1-indexed, first line is line 1)\n\t2. Ellipsis Usage - For large sections (>6 lines), use ellipsis (...) to include only the first few and last few key identifying lines for cleaner, more focused matching\n\t3. Content Validation - The prefix and suffix parts of search (before and after ellipsis) must contain exact content matches from the file (without line numbers). The tool validates these parts against the actual file content\n\t4. File Validation - The file must exist and be readable\n\t5. Parallel Tool Calls - When multiple edits are needed, invoke necessary tools simultaneously in parallel. Do NOT wait for one edit to complete before starting the next\n\t6. Original Line Numbers - When making multiple edits to the same file, always use original line numbers from your initial view of the file",
//   schema: z.object({
//     file_to_edit: z.string().describe("file path of the old file to edit new update generated by AI"),
//     new_file: z.string().describe("new updated latest file given by the AI"),
//   })
// }
// )
const toolsByName = {
  [createfile.name]: createfile,
  [runShellCommands.name]: runShellCommands,
  [applyPatchTool.name]:applyPatchTool
};

const tools = Object.values(toolsByName);
const llmWithTools = llm.bindTools(tools);


const MessageState = z.object({
  messages: z.array(z.custom<BaseMessage>()).register(registry, MessagesZodMeta),
  llmCalls: z.number().optional()
})

type State = z.infer<typeof MessageState>;

async function llmCall(state: State) {

  if (state.llmCalls == 0){
    console.log("1st LLM CALLLLLLLL")
    const UiTemplate = await Bun.file('baseUIPrompt.txt').text();
  const llmResponse = await llmWithTools.invoke([
    new SystemMessage(`
You are THINKING_BOX, an AI website builder assistant specialized in creating and modifying web apps using React + Vite + Tailwind + TypeScript.

---

### Your Environment
You have access to three tools:
1. **run_shell_command** — to execute terminal commands (e.g., clone, install, build).
2. **create_file** — to create new files.
3. **update_file** — to modify existing files.

All operations must happen **inside a directory named **React-NEW**.  
Example path: **React-NEW\vite-template\**

---

### Starting Point
You are starting from scratch — there is no project yet.  
You must:
1. Run a shell command to clone the repository:
   ***bash
   git clone git@github.com:Diwaz/vite-template.git React-NEW/vite-template
      `),
    ...state.messages
  ])

  const newCallCount = state.llmCalls + 1
  console.log("state of llmCalls",state.llmCalls)
  return {
    messages: [...state.messages, llmResponse],
    llmCalls: newCallCount,
  }

  }else {

    const llmResponse = await llmWithTools.invoke([
      new SystemMessage(
        `
        You are THINKING_BOX, an AI assistant that edits and extends an existing React + Vite + Tailwind + TypeScript project.

---

### Environment
The project is located inside:
**React-NEW/vite-template/**

You have access to these tools:
1. **run_shell_command** — for terminal operations (optional, e.g., run build or preview).
2. **create_file** — to add new files or components.
3. **update_file** — to modify existing files.

---

### Context
You already cloned the repository:
**git@github.com:Diwaz/vite-template.git**

You were given its directory structure and contents earlier in a text file (for reference only).

Now, respond to user requests to modify or enhance this project.

---

### Responsibilities
1. Understand the user’s intent (add new feature, create page, redesign layout, etc.).
2. Identify which files to update or create.
3. Use **update_file** and **create_file** to implement clean, valid React + TypeScript code.
4. Use Tailwind CSS consistently via semantic utility classes.
5. Keep the design minimal, responsive, and visually balanced.

---

### Workflow
1. Analyze the request.
2. Plan minimal necessary edits.
3. Execute file operations (**update_file** / **create_file**).
4. Use **run_shell_command** only if explicitly required (e.g., install dependency or build).
5. Keep all explanations short (2–3 lines max).

---

### Output Rules
- Only show file updates or creations.
- Never reprint the entire repo or context again.
- No emojis or filler language.
- Use Markdown formatting for clarity (e.g., code blocks).

---

### Base Repo Reference
Working directory: **React-NEW/vite-template/**
Base repo: **git@github.com:Diwaz/vite-template.git**
`),
      ...state.messages
    ])
  const newCallCount = state.llmCalls + 1
  console.log("state of llmCalls",state.llmCalls)
  return {
    messages: [...state.messages, llmResponse],
    llmCalls: newCallCount,
  }

  }
  // const newCallCount = state.llmCalls + 1
  // console.log("state of llmCalls",state.llmCalls)
  // return {
  //   messages: [...state.messages, llmResponse],
  //   llmCalls: newCallCount,
  // }

}

async function toolNode(state: State) {
  const lastMessage = state.messages.at(-1);

  if (lastMessage == null || !isAIMessage(lastMessage)) {
    return {
      messages: [],
    }
  }

  const result: ToolMessage[] = [];
  for (const toolCall of lastMessage.tool_calls ?? []) {
    const tool = toolsByName[toolCall.name];
    if (!tool) continue;
    const observation = await tool.invoke(toolCall);
    result.push(
      new ToolMessage({
        tool_call_id: toolCall.id,
        content:observation
      })
    );

  }

  return {
    messages: result
  }

}
async function shouldContinue(state: State) {
  const lastMessage = state.messages.at(-1);
  if (lastMessage == null || !isAIMessage(lastMessage)) {
    return END
  }

  if (lastMessage.tool_calls?.length) {
    return "toolNode";
  }
  return END;
}

const agent = new StateGraph(MessageState)
  .addNode("llmCall", llmCall)
  .addNode("toolNode", toolNode)
  .addEdge(START, "llmCall")
  .addConditionalEdges("llmCall", shouldContinue, ["toolNode", END])
  .addEdge("toolNode", "llmCall")
  .compile();

const start_agent = async () => {
  let state:State = {
    messages: [],
    llmCalls:0,
  }
  while (true) {
    let inputFromUser = prompt("[You]:")

    if (inputFromUser?.toLowerCase() === "quit"){
      break;
    }
    if (!inputFromUser?.trim()){
      continue
    }
    state.messages.push(new HumanMessage(inputFromUser))
    const result = await agent.invoke(state)
    state = result

    for (const messages of state.messages) {
      // console.log("state messages",state.messages)
      // console.log(`[${messages._getType()}]:${JSON.stringify(messages.content)}`);
      console.log(`[${messages._getType()}]:${messages.content}`);

    }




  }



}
start_agent();
